{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "$id": "https://example.com/ddr3_microarchitecture.schema.json",
  "title": "DDR3 Memory Controller Microarchitecture Definition",
  "description": "Complete microarchitecture contract for frontend (RTL), backend (synthesis/PnR), and validation teams. All timing values are in nanoseconds (JEDEC-native). CL/CWL are in clock cycles. Conversion rule: nCK = ceil(param_ns / tCK_ns).",
  "type": "object",

  "required": [
    "schema_version",
    "design_id",
    "revision",
    "validation_scopes",
    "memory_model_boundary",
    "memory_geometry",
    "clocking_model",
    "timing_model",
    "controller_architecture",
    "initialization_sequence",
    "calibration",
    "host_interface",
    "data_path_mapping",
    "phy_interface",
    "csr_register_map",
    "observability",
    "implementation_targets"
  ],

  "properties": {

    "schema_version": {
      "type": "string",
      "pattern": "^[0-9]+\\.[0-9]+\\.[0-9]+$",
      "description": "Semantic version of this schema. All teams must reference the same version."
    },

    "design_id": {
      "type": "string",
      "description": "Unique identifier for this controller design."
    },

    "revision": {
      "type": "string",
      "description": "Revision tag for this specific configuration instance."
    },

    "conversion_rules": {
      "type": "object",
      "description": "Formal rules for converting spec-level ns values to RTL-level cycle counts. All teams MUST use these rules identically.",
      "properties": {
        "timing_ns_to_nCK": {
          "type": "string",
          "const": "ceil(param_ns / tCK_ns)",
          "description": "All timing parameters in ns are converted to cycles by ceiling division by tCK_ns. This conversion is performed by the microarchitecture agent and emitted as $derived fields. RTL uses the cycle values directly as localparam."
        },
        "conversion_owner": {
          "type": "string",
          "enum": ["microarchitecture_agent", "rtl_localparam"],
          "description": "Who performs the nsâ†’cycles conversion. 'microarchitecture_agent' means $derived cycle values are authoritative. 'rtl_localparam' means RTL does the conversion at elaboration time."
        },
        "rounding_rule": {
          "type": "string",
          "const": "ceiling",
          "description": "Always round UP to next integer cycle. Never truncate."
        }
      }
    },

    "validation_scopes": {
      "type": "array",
      "items": {
        "type": "string",
        "enum": [
          "config_regs",
          "arbiter",
          "scheduler",
          "timing",
          "init_sequence",
          "calibration",
          "refresh",
          "data_path",
          "full_controller"
        ]
      },
      "minItems": 1,
      "description": "Ordered list of verification scopes. Validation planner uses this to generate test plans."
    },

    "memory_model_boundary": {
      "type": "object",
      "description": "Defines what is modeled and what is abstracted. Aligns frontend, backend, and validation on scope.",
      "required": ["boundary_type", "phy_modeled", "read_data_model"],
      "properties": {
        "boundary_type": {
          "type": "string",
          "enum": ["abstract_cmd_data", "pin_accurate"],
          "description": "abstract_cmd_data: command/data boundary without PHY. pin_accurate: full DQ/DQS signals."
        },
        "phy_modeled": {
          "type": "boolean",
          "description": "If false, no SERDES/IODELAY/bitslip is in scope."
        },
        "supports_training": {
          "type": "boolean",
          "description": "Whether write/read leveling training is modeled."
        },
        "supports_mpr": {
          "type": "boolean",
          "description": "Whether MPR readout is modeled."
        },
        "read_data_model": {
          "type": "string",
          "enum": ["fixed_latency_from_CL", "phy_captured"],
          "description": "How read data appears: fixed_latency_from_CL means data returns CL cycles after READ command."
        },
        "notes": { "type": "string" }
      }
    },

    "memory_geometry": {
      "type": "object",
      "required": [
        "row_bits",
        "column_bits",
        "bank_bits",
        "ranks",
        "burst_length",
        "device_width_bits",
        "byte_lanes",
        "address_mapping"
      ],
      "properties": {
        "row_bits": { "type": "integer", "minimum": 12, "maximum": 16 },
        "column_bits": { "type": "integer", "minimum": 10, "maximum": 12 },
        "bank_bits": { "type": "integer", "const": 3, "description": "DDR3 always has 8 banks." },
        "ranks": { "type": "integer", "minimum": 1, "maximum": 4 },
        "burst_length": { "type": "integer", "enum": [4, 8] },
        "device_width_bits": { "type": "integer", "enum": [8, 16] },
        "byte_lanes": { "type": "integer", "minimum": 1, "maximum": 8 },
        "address_mapping": {
          "type": "string",
          "enum": ["row-bank-column", "bank-row-column"]
        }
      }
    },

    "clocking_model": {
      "type": "object",
      "required": [
        "controller_clock_period_ns",
        "ddr_clock_period_ns",
        "clock_ratio_ddr_to_controller",
        "pipeline_latency_cycles"
      ],
      "properties": {
        "controller_clock_period_ns": {
          "type": "number",
          "exclusiveMinimum": 0,
          "description": "Controller domain clock period in nanoseconds."
        },
        "ddr_clock_period_ns": {
          "type": "number",
          "exclusiveMinimum": 0,
          "description": "DDR clock (tCK) period in nanoseconds. This is the reference for all timing conversions."
        },
        "clock_ratio_ddr_to_controller": {
          "type": "integer",
          "const": 4,
          "description": "controller_clock_period_ns / ddr_clock_period_ns. Fixed at 4:1."
        },
        "pipeline_latency_cycles": {
          "type": "integer",
          "minimum": 1,
          "maximum": 4,
          "description": "Number of pipeline stages in the controller command path (controller clock domain)."
        }
      }
    },

    "timing_model": {
      "type": "object",
      "description": "All timing parameters in nanoseconds (JEDEC-native). CL and CWL are in clock cycles. The $derived section provides cycle equivalents computed via ceil(param_ns / tCK_ns).",
      "required": [
        "units",
        "tCK_ns",
        "speed_bin",
        "tRCD", "tRP", "tRAS", "tRC",
        "tRFC", "tFAW", "tRRD",
        "tWR", "tWTR", "tRTP",
        "tCCD", "tREFI",
        "CL_cycles", "CWL_cycles"
      ],
      "properties": {
        "units": { "type": "string", "const": "ns" },
        "tCK_ns": {
          "type": "number",
          "exclusiveMinimum": 0,
          "description": "Clock period in ns. Must match clocking_model.ddr_clock_period_ns."
        },
        "speed_bin": {
          "type": "string",
          "description": "JEDEC speed bin identifier (e.g. 'DDR3-1600K (11-11-11)')."
        },
        "tRCD": { "type": "number", "exclusiveMinimum": 0, "description": "RAS-to-CAS delay (ns)" },
        "tRP": { "type": "number", "exclusiveMinimum": 0, "description": "Row precharge time (ns)" },
        "tRAS": { "type": "number", "exclusiveMinimum": 0, "description": "Row active time (ns)" },
        "tRC": { "type": "number", "exclusiveMinimum": 0, "description": "Row cycle time (ns). Must equal tRAS + tRP." },
        "tRFC": { "type": "number", "exclusiveMinimum": 0, "description": "Refresh cycle time (ns). Depends on device density." },
        "tFAW": { "type": "number", "exclusiveMinimum": 0, "description": "Four-activate window (ns)." },
        "tRRD": { "type": "number", "exclusiveMinimum": 0, "description": "Row-to-row activate delay (ns)." },
        "tWR": { "type": "number", "exclusiveMinimum": 0, "description": "Write recovery time (ns). JEDEC fixed at 15ns." },
        "tWTR": { "type": "number", "exclusiveMinimum": 0, "description": "Write-to-read turnaround (ns)." },
        "tRTP": { "type": "number", "exclusiveMinimum": 0, "description": "Read-to-precharge time (ns)." },
        "tCCD": { "type": "number", "exclusiveMinimum": 0, "description": "CAS-to-CAS delay (ns). 4*tCK for BL8." },
        "tREFI": { "type": "number", "exclusiveMinimum": 0, "description": "Refresh interval (ns). JEDEC standard 7800ns (7.8us)." },
        "CL_cycles": {
          "type": "integer", "minimum": 5, "maximum": 14,
          "description": "CAS latency in clock cycles. Determines MR0 encoding."
        },
        "CWL_cycles": {
          "type": "integer", "minimum": 5, "maximum": 12,
          "description": "CAS write latency in clock cycles. Determined by tCK per JEDEC table."
        }
      }
    },

    "controller_architecture": {
      "type": "object",
      "required": [
        "num_ports",
        "scheduler_policy",
        "row_policy",
        "command_queue_depth",
        "lookahead_depth",
        "ecc_mode",
        "self_refresh_mode",
        "refresh_policy",
        "bist_config"
      ],
      "properties": {
        "num_ports": { "type": "integer", "minimum": 1, "maximum": 4 },

        "arbiter_policy": {
          "type": "string",
          "enum": ["round_robin", "fixed_priority", "weighted_round_robin"],
          "description": "Multi-port arbitration scheme. Required when num_ports > 1."
        },

        "scheduler_policy": {
          "type": "string",
          "enum": ["in_order", "fr_fcfs"]
        },

        "row_policy": {
          "type": "string",
          "enum": ["open_page", "close_page"]
        },

        "command_queue_depth": {
          "type": "integer",
          "minimum": 4,
          "maximum": 64
        },

        "lookahead_depth": {
          "type": "integer",
          "minimum": 0,
          "maximum": 32
        },

        "ecc_mode": {
          "type": "integer",
          "enum": [0, 1, 2, 3],
          "description": "0=disabled, 1=SEC-DED, 2=chipkill, 3=vendor-specific"
        },

        "self_refresh_mode": {
          "type": "string",
          "enum": ["disabled", "manual", "auto"]
        },

        "refresh_policy": {
          "type": "object",
          "description": "Refresh scheduling behavior.",
          "required": ["max_postpone_count", "refresh_priority"],
          "properties": {
            "max_postpone_count": {
              "type": "integer",
              "minimum": 0,
              "maximum": 8,
              "description": "Max number of refresh commands that can be postponed. JEDEC allows up to 8."
            },
            "refresh_priority": {
              "type": "string",
              "enum": ["normal", "urgent_preempt"],
              "description": "normal: refresh competes with traffic in scheduler. urgent_preempt: refresh preempts traffic when postpone count reaches threshold."
            },
            "urgent_threshold": {
              "type": "integer",
              "minimum": 1,
              "maximum": 8,
              "description": "Postpone count at which refresh becomes urgent (if urgent_preempt policy)."
            }
          }
        },

        "bist_config": {
          "type": "object",
          "description": "Built-in self-test configuration.",
          "required": ["enable"],
          "properties": {
            "enable": { "type": "boolean" },
            "pattern": {
              "type": "string",
              "enum": ["walking_ones", "walking_zeros", "checkerboard", "lfsr", "all_patterns"],
              "description": "BIST data pattern."
            },
            "address_mode": {
              "type": "string",
              "enum": ["sequential", "random_lfsr"],
              "description": "Address generation mode during BIST."
            },
            "address_range": {
              "type": "object",
              "properties": {
                "start": { "type": "integer", "minimum": 0 },
                "end": { "type": "integer", "minimum": 0 }
              },
              "description": "Byte address range to test. Default: full memory."
            }
          }
        },

        "error_handling": {
          "type": "object",
          "description": "Controller behavior on error conditions.",
          "properties": {
            "on_ecc_correctable": {
              "type": "string",
              "enum": ["correct_and_continue", "correct_and_interrupt"],
              "description": "Behavior on single-bit ECC error."
            },
            "on_ecc_uncorrectable": {
              "type": "string",
              "enum": ["poison_data", "interrupt_and_halt"],
              "description": "Behavior on multi-bit ECC error."
            },
            "on_refresh_starvation": {
              "type": "string",
              "enum": ["force_precharge_all", "interrupt"],
              "description": "Behavior when max_postpone_count is exceeded."
            },
            "on_init_failure": {
              "type": "string",
              "enum": ["retry", "halt_and_signal"],
              "description": "Behavior if init/calibration fails."
            }
          }
        },

        "enable_second_wishbone": { "type": "boolean" },
        "aux_width": { "type": "integer", "minimum": 4 }
      }
    },

    "initialization_sequence": {
      "type": "object",
      "description": "DDR3 JEDEC-mandated initialization and mode register programming. Timing in us/ns.",
      "required": [
        "reset_hold_us",
        "cke_delay_us",
        "tXPR_ns",
        "zq_calibration_on_init",
        "tZQinit_ns",
        "mode_registers"
      ],
      "properties": {
        "reset_hold_us": {
          "type": "integer",
          "minimum": 200,
          "description": "Duration to hold RESET# low after power stable (JEDEC min 200us)."
        },
        "cke_delay_us": {
          "type": "integer",
          "minimum": 500,
          "description": "Delay after RESET# deassert before CKE goes high (JEDEC min 500us)."
        },
        "tXPR_ns": {
          "type": "number",
          "exclusiveMinimum": 0,
          "description": "Wait after CKE high before first MRS. JEDEC: max(5*tCK, tRFC+10ns)."
        },
        "zq_calibration_on_init": {
          "type": "boolean",
          "description": "Issue ZQCL (long calibration) command during initialization."
        },
        "tZQinit_ns": {
          "type": "number",
          "exclusiveMinimum": 0,
          "description": "ZQ calibration duration. JEDEC: 512*tCK."
        },
        "mode_registers": {
          "type": "object",
          "required": ["MR0", "MR1", "MR2", "MR3"],
          "properties": {
            "MR0": {
              "type": "object",
              "description": "Mode Register 0: burst length, CAS latency, DLL reset, write recovery.",
              "required": ["burst_length", "cas_latency_cycles", "dll_reset", "write_recovery_ns"],
              "properties": {
                "burst_length": {
                  "type": "string",
                  "enum": ["fixed_8", "on_the_fly_4_8"]
                },
                "cas_latency_cycles": {
                  "type": "integer",
                  "minimum": 5,
                  "maximum": 14,
                  "description": "Must match timing_model.CL_cycles."
                },
                "dll_reset": { "type": "boolean" },
                "write_recovery_ns": {
                  "type": "number",
                  "description": "Must match timing_model.tWR."
                },
                "precharge_pd_mode": {
                  "type": "string",
                  "enum": ["slow_exit", "fast_exit"]
                }
              }
            },
            "MR1": {
              "type": "object",
              "description": "Mode Register 1: DLL enable, drive strength, ODT, write leveling, AL.",
              "required": ["dll_enable", "output_drive_strength", "rtt_nom", "additive_latency"],
              "properties": {
                "dll_enable": { "type": "boolean" },
                "output_drive_strength": {
                  "type": "string",
                  "enum": ["RZQ_6", "RZQ_7"]
                },
                "rtt_nom": {
                  "type": "string",
                  "enum": ["disabled", "RZQ_4", "RZQ_2", "RZQ_6", "RZQ_12", "RZQ_8"]
                },
                "additive_latency": {
                  "type": "string",
                  "enum": ["disabled", "CL_minus_1", "CL_minus_2"]
                },
                "write_leveling_enable": { "type": "boolean" }
              }
            },
            "MR2": {
              "type": "object",
              "description": "Mode Register 2: CAS write latency, dynamic ODT, self-refresh temp.",
              "required": ["cas_write_latency_cycles", "rtt_wr"],
              "properties": {
                "cas_write_latency_cycles": {
                  "type": "integer",
                  "minimum": 5,
                  "maximum": 12,
                  "description": "Must match timing_model.CWL_cycles."
                },
                "rtt_wr": {
                  "type": "string",
                  "enum": ["disabled", "RZQ_4", "RZQ_2"]
                },
                "self_refresh_temperature": {
                  "type": "string",
                  "enum": ["normal", "extended"]
                },
                "auto_self_refresh": { "type": "boolean" }
              }
            },
            "MR3": {
              "type": "object",
              "description": "Mode Register 3: MPR control.",
              "properties": {
                "mpr_enable": { "type": "boolean" },
                "mpr_read_function": { "type": "integer", "enum": [0] }
              }
            }
          }
        }
      }
    },

    "calibration": {
      "type": "object",
      "description": "Read/write calibration and training parameters.",
      "required": [
        "enable_write_leveling",
        "enable_read_leveling",
        "enable_bitslip_training",
        "calibration_retry_count",
        "periodic_recalibration_enable",
        "periodic_zqcs_interval_ns"
      ],
      "properties": {
        "enable_write_leveling": { "type": "boolean" },
        "enable_read_leveling": { "type": "boolean" },
        "enable_bitslip_training": { "type": "boolean" },
        "read_delay_scan_range": {
          "type": "object",
          "properties": {
            "min_taps": { "type": "integer", "minimum": 0 },
            "max_taps": { "type": "integer", "minimum": 1 },
            "step": { "type": "integer", "minimum": 1 }
          }
        },
        "write_delay_scan_range": {
          "type": "object",
          "properties": {
            "min_taps": { "type": "integer", "minimum": 0 },
            "max_taps": { "type": "integer", "minimum": 1 },
            "step": { "type": "integer", "minimum": 1 }
          }
        },
        "training_pattern": {
          "type": "string",
          "enum": ["mpr_predefined", "walking_ones", "lfsr", "custom"]
        },
        "calibration_retry_count": { "type": "integer", "minimum": 0 },
        "periodic_recalibration_enable": { "type": "boolean" },
        "periodic_zqcs_interval_ns": {
          "type": "number",
          "minimum": 0,
          "description": "Interval between periodic ZQCS commands in ns. 0 = disabled."
        }
      }
    },

    "host_interface": {
      "type": "object",
      "description": "Wishbone bus interface definition for host-side connectivity.",
      "required": [
        "interface_type",
        "addressing",
        "data_width_bits",
        "address_width_bits",
        "granularity_bits"
      ],
      "properties": {
        "interface_type": {
          "type": "string",
          "enum": ["wishbone_classic", "wishbone_pipelined"]
        },
        "addressing": {
          "type": "string",
          "enum": ["byte", "word"],
          "description": "Addressing mode. byte = each address selects one byte."
        },
        "data_width_bits": {
          "type": "integer",
          "enum": [32, 64, 128]
        },
        "address_width_bits": {
          "type": "integer",
          "minimum": 20,
          "maximum": 32
        },
        "granularity_bits": {
          "type": "integer",
          "enum": [8, 16, 32]
        },
        "burst_type": {
          "type": "string",
          "enum": ["none", "linear", "wrap"]
        },
        "max_burst_length": { "type": "integer", "minimum": 1 },
        "read_buffer_depth": { "type": "integer", "minimum": 1 },
        "write_buffer_depth": { "type": "integer", "minimum": 1 },
        "enable_data_mask": { "type": "boolean" }
      }
    },

    "data_path_mapping": {
      "type": "object",
      "description": "Defines how host data width maps to DDR channel data width.",
      "required": [
        "ddr_channel_width_bits",
        "host_width_bits",
        "pack_mode",
        "endianness"
      ],
      "properties": {
        "ddr_channel_width_bits": {
          "type": "integer",
          "description": "device_width_bits * byte_lanes"
        },
        "host_width_bits": {
          "type": "integer",
          "description": "Must match host_interface.data_width_bits"
        },
        "pack_mode": {
          "type": "string",
          "enum": ["pack_32_to_16", "pack_64_to_16", "pack_32_to_32", "direct"],
          "description": "How host words are serialized onto the DDR bus."
        },
        "alignment_bytes_required": { "type": "integer", "minimum": 1 },
        "endianness": {
          "type": "string",
          "enum": ["little", "big"]
        },
        "byte_enable_semantics": {
          "type": "string",
          "enum": ["wishbone_sel_per_byte", "axi_strobe"],
          "description": "How byte enables are interpreted."
        }
      }
    },

    "phy_interface": {
      "type": "object",
      "description": "DRAM-side physical interface definition. Can be abstract or pin-accurate.",
      "required": ["mode", "dq_width_bits", "dqs_count", "dm_enabled"],
      "properties": {
        "mode": {
          "type": "string",
          "enum": ["abstract", "pin_accurate"]
        },
        "dq_width_bits": { "type": "integer", "description": "Total DQ pin count." },
        "dqs_count": { "type": "integer", "description": "Number of DQS pairs." },
        "dm_enabled": { "type": "boolean" },
        "ck_pair_present": { "type": "boolean" },
        "notes": { "type": "string" }
      }
    },

    "csr_register_map": {
      "type": "object",
      "description": "Config/Status Register address map. Frontend builds config_regs.sv from this. Backend synthesizes it. Validation writes checkers against it.",
      "required": ["base_address", "address_width_bits", "data_width_bits", "registers"],
      "properties": {
        "base_address": {
          "type": "string",
          "pattern": "^0x[0-9a-fA-F]+$",
          "description": "Base address of CSR block in host address space."
        },
        "address_width_bits": {
          "type": "integer",
          "description": "Number of address bits for CSR space."
        },
        "data_width_bits": {
          "type": "integer",
          "enum": [32],
          "description": "CSR data bus width."
        },
        "registers": {
          "type": "array",
          "items": {
            "type": "object",
            "required": ["name", "offset", "access", "fields"],
            "properties": {
              "name": { "type": "string" },
              "offset": {
                "type": "string",
                "pattern": "^0x[0-9a-fA-F]+$",
                "description": "Byte offset from base_address."
              },
              "access": {
                "type": "string",
                "enum": ["RW", "RO", "WO", "RW1C"],
                "description": "RW=read-write, RO=read-only, WO=write-only, RW1C=write-1-to-clear."
              },
              "reset_value": {
                "type": "string",
                "pattern": "^0x[0-9a-fA-F]+$"
              },
              "fields": {
                "type": "array",
                "items": {
                  "type": "object",
                  "required": ["name", "bits", "access", "description"],
                  "properties": {
                    "name": { "type": "string" },
                    "bits": {
                      "type": "string",
                      "description": "Bit range, e.g. '7:0' or '31'."
                    },
                    "access": {
                      "type": "string",
                      "enum": ["RW", "RO", "WO", "RW1C"]
                    },
                    "reset_value": { "type": "integer" },
                    "description": { "type": "string" }
                  }
                }
              }
            }
          }
        }
      }
    },

    "latency_model": {
      "type": "object",
      "description": "End-to-end latency formulas for validation reference model. All in DDR clock cycles (nCK).",
      "properties": {
        "read_hit_latency_nCK": {
          "type": "string",
          "description": "Formula: pipeline_latency * clock_ratio + CL + burst_length/2 + data_alignment. Row already open, correct bank."
        },
        "read_miss_latency_nCK": {
          "type": "string",
          "description": "Formula: pipeline_latency * clock_ratio + tRP + tRCD + CL + burst_length/2 + data_alignment. Wrong row open."
        },
        "read_empty_latency_nCK": {
          "type": "string",
          "description": "Formula: pipeline_latency * clock_ratio + tRCD + CL + burst_length/2 + data_alignment. Bank idle."
        },
        "write_hit_latency_nCK": {
          "type": "string",
          "description": "Formula: pipeline_latency * clock_ratio + CWL + burst_length/2 + tWR."
        },
        "write_to_read_turnaround_nCK": {
          "type": "string",
          "description": "Formula: CWL + burst_length/2 + tWTR."
        },
        "read_to_write_turnaround_nCK": {
          "type": "string",
          "description": "Formula: CL + tCCD + 2 - CWL (typical, controller-specific)."
        }
      }
    },

    "observability": {
      "type": "object",
      "description": "Debug/validation signal requirements per scope. Validation agents probe these signals.",
      "required": ["debug_interface_name", "required_signals_by_scope"],
      "properties": {
        "debug_interface_name": { "type": "string" },
        "required_signals_by_scope": {
          "type": "object",
          "additionalProperties": {
            "type": "array",
            "items": { "type": "string" }
          },
          "description": "Map from validation_scope name to list of required signal names."
        }
      }
    },

    "failure_taxonomy": {
      "type": "object",
      "description": "Error classification for validation failure agent. Defines categories and severity.",
      "properties": {
        "categories": {
          "type": "array",
          "items": {
            "type": "object",
            "required": ["id", "name", "severity", "description"],
            "properties": {
              "id": { "type": "string" },
              "name": { "type": "string" },
              "severity": {
                "type": "string",
                "enum": ["critical", "major", "minor"]
              },
              "description": { "type": "string" },
              "scope": {
                "type": "string",
                "description": "Which validation_scope this failure belongs to."
              }
            }
          }
        }
      }
    },

    "implementation_targets": {
      "type": "object",
      "required": [
        "target_frequency_mhz",
        "area_optimization_goal",
        "power_optimization_goal",
        "clock_name",
        "reset_name",
        "reset_polarity"
      ],
      "properties": {
        "target_frequency_mhz": { "type": "number", "minimum": 1 },
        "area_optimization_goal": {
          "type": "string",
          "enum": ["area", "balanced", "performance"]
        },
        "power_optimization_goal": {
          "type": "string",
          "enum": ["low_power", "balanced", "performance"]
        },
        "clock_name": {
          "type": "string",
          "description": "Top-level clock port name for SDC constraints."
        },
        "reset_name": {
          "type": "string",
          "description": "Top-level reset port name."
        },
        "reset_polarity": {
          "type": "string",
          "enum": ["active_low", "active_high"]
        }
      }
    }
  }
}
